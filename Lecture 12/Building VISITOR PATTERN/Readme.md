# **Пример с Visitor Pattern за Различни Сгради**

## **Описание**

Имаме човек и различни сгради - **House**, **Factory**, **Bank**. Всеки ден на един човек му се налага да посети различни сгради и във всяка от тях да извърши различно действие:

- **House** => човекът спи
- **Factory** => човекът работи
- **Bank** => човекът тегли пари

### **Класът Person**

Класът `Person` съдържа методи за посещение на всяка от тези сгради:

```cpp
class Person {
public:
    void visit(const House* house) {
        std::cout << "sleep";
    }
    void visit(const Factory* factory) {
        std::cout << "work";
    }
    void visit(const Bank* bank) {
        std::cout << "withdraw";
    }
};
```
# **Описание на Задачата**

Целта е да създадем списък от сгради (**Building\*\***), които един човек трябва да обиколи през деня и да извърши различно действие във всяка една от тях.

## **Проблем**

За да определим какво действие трябва да изпълни човекът, трябва да знаем каква сграда стои зад всеки указател към **Building\***.

## **Решение**

Всяка сграда ще има функция за приемане на посетител (човек):

```cpp
virtual void accept(Person* person) = 0;
```
Във всяка от имплементациите във всеки от наследниците ще се вика различна функция на човека.

Сега нашия човек ще посети сградите по следния начин
```cpp
for (size_t i = 0; i < 3; i++) {
    buildings[i]->accept(&person);
    std::cout << std::endl;
}
```
Понеже accept е виртуална, при всяко извикване ние ще отиваме в една от трите имплементации на наследниците. Вече щом се намираме в конкретна имплементация, знаем и в кой клас се намираме (благодарение на this pointer).

Имплементация на accept метод във factory класа:
```cpp
void accept(Person* person) override {
    person->visit(this);
}
```
Тук вече ще идем в съответната функция, която приема Factory, на човека понеже this и от тип Factory* const.

В останалите е аналогично.
